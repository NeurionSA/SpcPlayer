using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NAudio.Wave;
using NAudio.CoreAudioApi;

namespace SpcPlayer.SPC
{
    /// <summary>
    /// Class responsible for the playback of the audio generated by the running of an SPC core and its associated DSP.
    /// </summary>
    internal class SPCPlayer : IDisposable, IWaveProvider
    {

        private const int PLAYBACK_RATE = 32000;

        // the loaded SPC file
        private SPCFile? _spcFile;

        // the SPC emulation core the player draws samples from
        private SPCCore _core;

        // audio device to send wave data to
        private WasapiOut _waveDevice;

        // the wave format the wave device has been opened with
        private WaveFormat _waveFormat;

        public event EventHandler<EventArgs>? PlaybackStopped;

        public SPCPlayer(SPCCore core)
        {
            // check arguments
            ArgumentNullException.ThrowIfNull(core);

            _waveFormat = new WaveFormat(PLAYBACK_RATE, 16, 2);
            _core = core;

            // create and open the audio device
            _waveDevice = new WasapiOut(AudioClientShareMode.Shared, 50);
            // register the event handler for playback stopping
            _waveDevice.PlaybackStopped += waveDevice_PlaybackStopped;

            // open the device using this Player as the WaveProvider
            _waveDevice.Init(this);
        }

        /// <summary>
        /// Loads an SPC file for playback.
        /// </summary>
        /// <param name="filename"></param>
        public void LoadSPC(string filename)
        {
            // check arguments
            ArgumentNullException.ThrowIfNull(filename);
            // check state
            if (_waveDevice.PlaybackState != PlaybackState.Stopped) throw new InvalidOperationException("Cannot load an SPC file while one is playing.");

            // load the file
            _spcFile = new SPCFile(filename);
            _core.LoadStateFromFile(_spcFile);
        }

        /// <summary>
        /// Starts playback or resumes playback if it's paused.
        /// </summary>
        public void Play()
        {
            // check if a file is loaded
            if (_spcFile == null) throw new InvalidOperationException("SPC file has not been loaded.");

            // check if the file is not currently playing
            if (_waveDevice.PlaybackState == PlaybackState.Stopped)
            {
                // start playback
                _waveDevice.Play();
            }
            else if (_waveDevice.PlaybackState == PlaybackState.Paused)
            {
                // resume playback
                _waveDevice.Play();
            }
        }

        /// <summary>
        /// Pauses playback.
        /// </summary>
        public void Pause()
        {
            // check if a file is loaded
            if (_spcFile == null) throw new InvalidOperationException("SPC file has not been loaded.");

            if (_waveDevice.PlaybackState == PlaybackState.Playing)
            {
                _waveDevice.Pause();
            }
        }

        /// <summary>
        /// Stops playback.
        /// </summary>
        public void Stop()
        {
            // check if a file is loaded
            if (_spcFile == null) throw new InvalidOperationException("SPC file has not been loaded.");

            if (_waveDevice.PlaybackState != PlaybackState.Stopped)
            {
                _waveDevice.Stop();

                // dump the contents of the event log
                _core.DSP.DumpEventLog();
                // reset the core to its initial state
                _core.Reset();
            }
        }

        protected virtual void OnPlaybackStopped(EventArgs e)
        {
            EventHandler<EventArgs> handler = PlaybackStopped!;
            if (handler != null)
            {
                handler(this, e);
            }
        }

        private void waveDevice_PlaybackStopped(object? sender, StoppedEventArgs e)
        {
            Console.WriteLine("[PLAYER] Playback has stopped.");
            if (e.Exception != null)
            {
                Console.WriteLine("Exception: {0}", e.Exception.ToString());
            }

            EventArgs args = new EventArgs();
            OnPlaybackStopped(args);
        }

        public PlaybackState Status => _waveDevice.PlaybackState;       

        #region IWaveProvider
        public WaveFormat WaveFormat => _waveFormat;

        /// <summary>
        /// Method called by the wave output device when it wants data.
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        public int Read(byte[] buffer, int offset, int count)
        {
            // determine how many samples the device is asking for
            int byteCount = count - (int)_core.DSP.BufferLength;
            int sampleCount = byteCount / _waveFormat.BlockAlign;

            // command the SPC core to run for at least a specific number of clock cycles
            // this is the requested size of the buffer, divided by the playback rate, times the SPC's CPU clock speed
            int numCycles = (int)Math.Ceiling(sampleCount / (float)PLAYBACK_RATE * 1024000);

            _core.ExecuteCycles(numCycles);

            // retrieve the desired number of samples from the DSP
            byte[] synthBytes = _core.DSP.RetrieveSamples(count);

            // copy the samples to the device
            Array.Copy(synthBytes, buffer, synthBytes.Length);

            return synthBytes.Length;
        }

        #endregion
        #region IDisposable
        private bool disposedValue;

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // TODO: dispose managed state (managed objects)
                }

                // TODO: free unmanaged resources (unmanaged objects) and override finalizer
                // TODO: set large fields to null
                disposedValue = true;
            }
        }

        // // TODO: override finalizer only if 'Dispose(bool disposing)' has code to free unmanaged resources
        // ~Player()
        // {
        //     // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
        //     Dispose(disposing: false);
        // }

        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}
